<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>Star Towers vs Hulks ‚Äî SVG Road (Free Placement)</title>
<style>
  html, body {
    margin:0;
    height:100%;
    background:#0b1020;
    color:#e8f0ff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  #wrap{
    display:flex;
    flex-direction:column;
    height:100%;
  }
  header{
    padding:8px 12px;
    background:#0e1630;
    box-shadow: 0 2px 0 rgba(0,0,0,.3);
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:8px;
    flex-wrap:wrap;
  }
  #hud {
    display:flex;
    gap:16px;
    font-weight:700;
  }
  #toolbar{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .btn{
    user-select:none;
    -webkit-user-select:none;
    padding:8px 10px;
    background:#1b2752;
    border:2px solid #2a3c7c;
    border-radius:10px;
    font-weight:700;
    cursor:pointer;
    font-size: 12px;
  }
  .btn.sel{
    outline:3px solid #7aa2ff;
  }
  .btn:active{
    filter:brightness(1.2);
  }
  #game {
    flex:1;
    display:grid;
    place-items:center;
    touch-action:none;
  }
  #stage {
    position: relative;
    width: 960px;
    max-width: 100%;
    aspect-ratio: 8 / 5;
  }
  #road {
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
  }
  canvas{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    background:#0a0f1e;
    border:2px solid #22356d;
    border-radius:12px;
  }
  footer{
    padding:6px 10px;
    font-size:12px;
    opacity:.8;
    background:#0e1630;
  }

  @media (max-width: 768px) {
    .btn{
      font-size: 11px;
      padding:6px 8px;
    }
  }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div id="hud">
      <div>üí∞ <span id="gold">250</span></div>
      <div>‚ù§Ô∏è <span id="lives">20</span></div>
      <div>Wave <span id="wave">1</span>/<span id="waveMax">10</span></div>
      <div>‚≠ê <span id="score">0</span></div>
    </div>
    <div id="toolbar">
      <div class="btn sel" id="t1">Blaster of Star (50)</div>
      <div class="btn" id="t2">Cold Star (60)</div>
      <div class="btn" id="t3">Exploding Star (80)</div>
      <div class="btn" id="start">‚ñ∂Ô∏è Send Wave</div>
      <div class="btn" id="sell">üí∏ Sell</div>
      <div class="btn" id="help">‚ùì</div>
    </div>
  </header>
  <div id="game">
    <div id="stage" aria-label="Play field">
      <!-- Always-visible SVG road -->
      <svg id="road" viewBox="0 0 960 600" preserveAspectRatio="none">
        <defs>
          <filter id="soften" x="-20%" y="-20%" width="140%" height="140%">
            <feGaussianBlur stdDeviation="1.2"/>
          </filter>
        </defs>
        <!-- outer/border gloss -->
        <path d="M40,330 160,330 220,228 360,228 420,348 580,348 620,192 780,132 900,132 900,510"
              stroke="rgba(255,255,255,0.06)" stroke-linecap="round" stroke-width="77" fill="none"/>
        <!-- base -->
        <path d="M40,330 160,330 220,228 360,228 420,348 580,348 620,192 780,132 900,132 900,510"
              stroke="#54412b" stroke-linecap="round" stroke-width="70" fill="none" filter="url(#soften)"/>
        <!-- inner lighter strip -->
        <path d="M40,330 160,330 220,228 360,228 420,348 580,348 620,192 780,132 900,132 900,510"
              stroke="#6b5134" stroke-linecap="round" stroke-width="44" fill="none"/>
      </svg>
      <canvas id="c" width="960" height="600"></canvas>
    </div>
  </div>
  <footer>Tap off the brown road to place towers. Tap a tower to upgrade. Tap ‚ÄúSell‚Äù then a tower to sell.</footer>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const goldEl = document.getElementById('gold');
  const livesEl = document.getElementById('lives');
  const waveEl = document.getElementById('wave');
  const waveMaxEl = document.getElementById('waveMax');
  const scoreEl = document.getElementById('score');

  const t1Btn = document.getElementById('t1');
  const t2Btn = document.getElementById('t2');
  const t3Btn = document.getElementById('t3');
  const startBtn = document.getElementById('start');
  const sellBtn = document.getElementById('sell');
  const helpBtn = document.getElementById('help');

  // Match canvas drawing size to CSS size
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  const W = 960;
  const H = 600;

  // Path points (match SVG path)
  const pathPoints = [
    {x: 40,  y: 330},
    {x: 160, y: 330},
    {x: 220, y: 228},
    {x: 360, y: 228},
    {x: 420, y: 348},
    {x: 580, y: 348},
    {x: 620, y: 192},
    {x: 780, y: 132},
    {x: 900, y: 132},
    {x: 900, y: 510}
  ];

  const ROAD_BLOCK_RADIUS = 40; // can't place within ~40px of path

  // Game state
  let gold = 100;
  let lives = 20;
  let score = 0;
  let wave = 1;
  const waveMax = 10;
  waveMaxEl.textContent = waveMax;
  let spawning = false;
  let spawnTick = 0;
  let spawnLeft = 0;

  const towers = [];
  const projectiles = [];
  const explosions = [];
  const hulks = [];

  const towerDefs = {
    t1: { name:"Blaster of Star", cost:50, range:120, rof:20, dmg:12, color:"#7dd3fc", bulletSpeed:9, upgrade:(lvl)=>({cost:40+15*lvl,dmg:7,range:12,rof:-2}) },
    t2: { name:"Cold Star", cost:60, range:110, rof:28, dmg:8, color:"#a7f3d0", bulletSpeed:8, slow:0.45, slowTime:2.0, upgrade:(lvl)=>({cost:45+18*lvl,dmg:5,range:10,rof:-2,slowTime:0.5}) },
    t3: { name:"Exploding Star", cost:80, range:115, rof:45, dmg:20, color:"#fca5a5", bulletSpeed:7, splash:45, upgrade:(lvl)=>({cost:55+22*lvl,dmg:10,range:10,rof:-3,splash:8}) }
  };

  let selectedTool = "t1";
  function selectTool(id){
    selectedTool = id;
    [t1Btn,t2Btn,t3Btn,sellBtn,startBtn,helpBtn].forEach(btn=>btn.classList.remove('sel'));
    ({t1:t1Btn,t2:t2Btn,t3:t3Btn,sell:sellBtn,start:startBtn,help:helpBtn}[id] || t1Btn).classList.add('sel');
  }
  t1Btn.addEventListener('click',()=>selectTool("t1"));
  t2Btn.addEventListener('click',()=>selectTool("t2"));
  t3Btn.addEventListener('click',()=>selectTool("t3"));
  sellBtn.addEventListener('click',()=>selectTool("sell"));
  startBtn.addEventListener('click',()=>startWave());
  helpBtn.addEventListener('click',()=>alert(
    "Free Placement + SVG Road:\\n- Tap anywhere off the brown road to place.\\n- Tap a tower to upgrade.\\n- Tap Sell then a tower to sell.\\nT1 Blaster: fast single-target.\\nT2 Cold: slows.\\nT3 Exploding: splash."
  ));

  canvas.addEventListener('click', onClick);
  canvas.addEventListener('touchstart', (e)=>{ const t=e.changedTouches[0]; onPointer(t.clientX, t.clientY); }, {passive:true});
  function onClick(e){ onPointer(e.clientX, e.clientY); }
  function onPointer(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const x = (clientX - rect.left) / rect.width * W;
    const y = (clientY - rect.top)  / rect.height * H;

    // hit tower?
    const hitT = towers.find(t => Math.hypot(t.x - x, t.y - y) <= 18);
    if (hitT){
      if (selectedTool==="sell"){
        gold += Math.floor(hitT.spent * 0.6);
        const idx = towers.indexOf(hitT); if (idx>=0) towers.splice(idx,1);
      } else {
        attemptUpgrade(hitT);
      }
      return;
    }

    if (!["t1","t2","t3"].includes(selectedTool)) return;
    const def = towerDefs[selectedTool];
    if (gold < def.cost) return;
    // don't place on road
    if (distanceToPath({x,y}) <= ROAD_BLOCK_RADIUS) return;
    for (const t of towers){ if (Math.hypot(t.x-x, t.y-y) < 28) return; }
    gold -= def.cost;
    towers.push(makeTower(selectedTool, x, y));
  }

  function attemptUpgrade(t){
    const def = towerDefs[t.type];
    const up = def.upgrade(t.level);
    const cost = up.cost;
    if (gold >= cost){
      gold -= cost;
      t.level++; t.spent += cost;
      t.dmg += up.dmg || 0;
      t.range += (up.range || 0);
      t.rof = Math.max(8, t.rof + (up.rof||0));
      t.splash = (t.splash||0) + (up.splash||0);
      t.slowTime = (t.slowTime||0) + (up.slowTime||0);
    }
  }

  function makeTower(type, x, y){
    const d = towerDefs[type];
    return {
      type, x, y, level:1,
      range: d.range, rof: d.rof, cd: 0, dmg: d.dmg,
      color: d.color, bulletSpeed: d.bulletSpeed, splash: d.splash, slow: d.slow, slowTime: d.slowTime,
      spent: d.cost
    };
  }

  function makeHulk(){
  const baseHp = 60 + wave * 8;  // much lower than before
  return {
    x: pathPoints[0].x, y: pathPoints[0].y,
    seg: 0,
    speed: 60,
    hp: baseHp,
    maxhp: baseHp,
    reward: 15 + wave * 2   // a bit more gold per kill
  };
}

  function startWave(){
    if (spawning) return;
    spawning = true;
    spawnLeft = 9 + Math.floor(wave*1.4);
    spawnTick = 0;
  }

  // LOOP
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(dt){
    if (spawning){
      spawnTick -= dt;
      if (spawnTick <= 0 && spawnLeft > 0){
        hulks.push(makeHulk());
        spawnLeft--;
        spawnTick = Math.max(0.35, 1.0 - wave*0.05);
      }
      if (spawnLeft<=0 && hulks.length===0){
        spawning = false;
        if (wave < waveMax) wave++;
      }
    }

    // move hulks
    for (const h of hulks){
      const a = pathPoints[h.seg];
      const b = pathPoints[h.seg+1];
      if (!b){ h._dead = true; lives--; continue; }
      const dx = b.x - a.x, dy = b.y - a.y;
      const dist = Math.hypot(dx, dy);
      if (dist === 0){ h.seg++; continue; }
      const dirx = dx/dist, diry = dy/dist;
      const slowed = (h.slowUntil && performance.now() < h.slowUntil) ? 0.55 : 1;
      const step = Math.min(dist, h.speed * slowed * dt);
      // project onto segment
      const px = h.x - a.x, py = h.y - a.y;
      const along = (px*dirx + py*diry) + step;
      if (along >= dist){ h.seg++; h.x = b.x; h.y = b.y; }
      else { h.x = a.x + dirx * along; h.y = a.y + diry * along; }
    }
    for (let i=hulks.length-1;i>=0;i--){ if (hulks[i]._dead) hulks.splice(i,1); }

    // towers fire
    for (const t of towers){
      t.cd -= dt;
      if (t.cd <= 0){
        let best=null, bestKey=-1;
        for (const h of hulks){
          const d = Math.hypot(h.x - t.x, h.y - t.y);
          if (d <= t.range){
            const k = h.seg + d*1e-4;
            if (k > bestKey){ bestKey = k; best = h; }
          }
        }
        if (best){ fire(t, best); t.cd = t.rof/60; }
      }
    }

    // projectiles
    for (const p of projectiles){
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const dist = Math.hypot(dx, dy);
      const step = p.speed * dt * 40;
      if (dist <= step || !p.target || p.target._dead){
        hit(p); p._dead = true; continue;
      }
      p.x += dx / dist * step;
      p.y += dy / dist * step;
      p.tx = p.target.x; p.ty = p.target.y;
    }
    for (let i=projectiles.length-1;i>=0;i--){ if (projectiles[i]._dead) projectiles.splice(i,1); }

    // explosions
    for (const ex of explosions){ ex.t += dt; if (ex.t > 0.25) ex._dead = true; }
    for (let i=explosions.length-1;i>=0;i--){ if (explosions[i]._dead) explosions.splice(i,1); }

    // deaths
    for (let i=hulks.length-1;i>=0;i--){
      const h = hulks[i];
      if (h.hp <= 0){
        hulks.splice(i,1);
        gold += h.reward;
        score += 10;
      }
    }

    // lose
    if (lives <= 0){
      alert("Defeat! The Hulks smashed through.\\nScore: "+score+"\\nRestarting...");
      gold = 100; lives = 20; score = 0; wave = 1;
      towers.length = 0; hulks.length = 0; projectiles.length = 0; explosions.length = 0;
      spawning = false; spawnLeft = 0;
    }

    goldEl.textContent = gold;
    livesEl.textContent = Math.max(0, lives);
    waveEl.textContent = wave;
    scoreEl.textContent = score;
  }

  function fire(t, target){
    const p = {
      ttype: t.type, x: t.x, y: t.y, tx: target.x, ty: target.y, target,
      speed: t.bulletSpeed, dmg: t.dmg, color: t.color,
      splash: t.splash || 0, slow: t.slow || 0, slowTime: t.slowTime || 0
    };
    projectiles.push(p);
  }

  function hit(p){
    if (p.splash){
      const r = p.splash;
      explosions.push({x:p.tx, y:p.ty, r, t:0});
      for (const h of hulks){
        const d = Math.hypot(h.x - p.tx, h.y - p.ty);
        if (d <= r) applyDamageAndEffects(h, p);
      }
    } else {
      if (p.target) applyDamageAndEffects(p.target, p);
    }
  }
  function applyDamageAndEffects(h, p){
    h.hp -= p.dmg;
    if (p.slow && p.slowTime){
      const until = performance.now() + p.slowTime*1000;
      h.slowUntil = Math.max(h.slowUntil||0, until);
    }
  }

  // geometry helpers
  function distanceToPath(pt){
    let best = Infinity;
    for (let i=0; i<pathPoints.length-1; i++){
      best = Math.min(best, distancePointToSegment(pt, pathPoints[i], pathPoints[i+1]));
    }
    return best;
  }
  function distancePointToSegment(p, a, b){
    const vx = b.x - a.x, vy = b.y - a.y;
    const wx = p.x - a.x, wy = p.y - a.y;
    const c1 = vx*wx + vy*wy;
    if (c1 <= 0) return Math.hypot(p.x - a.x, p.y - a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(p.x - b.x, p.y - b.y);
    const t = c1 / c2;
    const projx = a.x + t*vx, projy = a.y + t*vy;
    return Math.hypot(p.x - projx, p.y - projy);
  }

  function render(){
    const rect = canvas.getBoundingClientRect();
    const scaleX = rect.width / W;
    const scaleY = rect.height / H;
    const s = Math.min(scaleX, scaleY);
    ctx.setTransform(window.devicePixelRatio * s, 0, 0, window.devicePixelRatio * s, 0, 0);
    ctx.clearRect(0,0,W,H);

    // towers
    for (const t of towers){
      ctx.save();
      ctx.translate(t.x, t.y);
      ctx.fillStyle = t.color;
      drawStar(ctx, 5, 16, 8);
      ctx.fill();
      // range ring
      ctx.globalAlpha = 0.07;
      ctx.beginPath();
      ctx.arc(0, 0, t.range, 0, Math.PI*2);
      ctx.fillStyle = t.color;
      ctx.fill();
      // level pips
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      for (let i=0;i<t.level-1;i++){ ctx.fillRect(-18 + i*5, 18, 4, 4); }
      ctx.restore();
    }

    // projectiles
    for (const p of projectiles){
      ctx.strokeStyle = p.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.tx, p.ty);
      ctx.stroke();
    }
    // explosions
    for (const ex of explosions){
      ctx.save();
      const alpha = 1 - ex.t/0.25;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = "#fca5a5";
      ctx.beginPath();
      ctx.arc(ex.x, ex.y, ex.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
    // hulks
    for (const h of hulks){
      ctx.fillStyle = "#7cfc7a";
      ctx.beginPath();
      ctx.arc(h.x, h.y, 14, 0, Math.PI*2);
      ctx.fill();
      // hp bar
      const w = 36, hh = 5;
      const hpFrac = Math.max(0, h.hp / h.maxhp);
      ctx.fillStyle = "#111";
      ctx.fillRect(h.x - w/2, h.y - 22, w, hh);
      ctx.fillStyle = hpFrac>0.5 ? "#5bff5b" : (hpFrac>0.25 ? "#ffd75b" : "#ff6b6b");
      ctx.fillRect(h.x - w/2, h.y - 22, w*hpFrac, hh);
    }
  }

  function drawStar(ctx, spikes, outerR, innerR){
    let rot = Math.PI / 2 * 3;
    const step = Math.PI / spikes;
    ctx.beginPath();
    ctx.moveTo(0, -outerR);
    for (let i = 0; i < spikes; i++) {
      let x = Math.cos(rot) * outerR;
      let y = Math.sin(rot) * outerR;
      ctx.lineTo(x, y); rot += step;
      x = Math.cos(rot) * innerR;
      y = Math.sin(rot) * innerR;
      ctx.lineTo(x, y); rot += step;
    }
    ctx.lineTo(0, -outerR);
    ctx.closePath();
  }
})();
</script>
</body>
</html>
